@{
    ViewBag.Title = "About";
}

<h3>About</h3>
<p>
    This is a messaging application comprised of a client & a REST service. The client & the service have
    their own databases that store the username, roles, passwords, & messages. There are two user roles:
    'Users' can send & receive messages, & 'Admin' can send & receive messages, delete users, & change user roles.

    When a user sends a message, one version of the message is stored on the client database, & the other
    version is stored on the service database. The version on the client database belongs to the sender,
    & the one on the service database belongs to the receiver. When the reciever retrieves their messages
    from the service database, they are stored on the client database (duplicates of their version of the
    message are not stored). When a user is deleted, their sent messages that are stored on the client
    database are deleted, as well as their received messages that are stored on the service & the client
    databases.
</p>


<h3>Design</h3>
<p>
    To realize seperation of concerns, the business classes & the data access classes are
    decoupled by implementing the repository & the unit of work patterns. This also allows the
    persistence layer to be more easily swapped with another.

    In the client, a generic repository & its interface are implemented, & the repositories & their
    interfaces are implemented, as well as the unit of work & its interface. Unity Container is used
    to inject the repositories into the unit of work & to inject the unit of work into the constructor
    of each controller. A database context is instantiated in the unit of work constructor & is passed
    to the constructors of the repositories, so that they all share the same database context.

    The service was implemented similarly, but without the generic repository & its interface.

    To invoke REST calls to the service, interfaces & the classes that realize them are
    implemented & injected into the constructors of the controllers.
</p>


<h3>Hash</h3>
<p>
    Both the client & the servide use the PBKDF2 hashing process via the Rfc2898DeriveBytes class.
    It uses a 32 byte salt & 5000 iterations to hash the provided password, which returns a 32 byte
    hash. Each user has a unique salt that is generated by the RNGCryptoServiceProvider class. The
    hashed password, salt, & the iteration count are concatonated (seperated by a colon) & are stored
    in the client database. To validate users during login, the salt, the iteration count, & the provided
    password are used to generate a hash. This hash is compared to the stored hash. The service stores
    only the username & the hash in its database. To validate users when a token is requested, the
    provided hash is compared to the stored hash. The full length of the hashes are checked
    everytime to protect against timing attacks.
</p>


<h3>Token-based Authentication</h3>
<p>
    Token-based authentication is implemented to secure the service. When a user registers/logins,
    the client calls the service & passes the username & hashed password to it. The service validates
    the user by checking the provided hash against its stored hash. This is accomplished by the
    MyAuthorizationServerProvider class, which validates the credentials & generates the token.

    MyAuthorizationServerProvider inherits from the OAuthAuthorizationServerProvider class &
    overrides its GrantResourceOwnerCredentials method to validate the user name & hash. The ClaimTypes
    that are added to the ClaimsIdentity are the user name & roles. Once the user is validated, a bearer
    token is generated. The token is saved in the Authorization header of the httpclient, & is sent to
    the server for every request.
</p>


<h3>HttpClient</h3>
<p>
    A single instance of HttpClient is used. It is instantiated & congigured once in
    Global.Application_Start. This mitigates the risk of socket connections being unavailable.
    Since each instance of HttpClient opens a new socket connection, the available pool can be
    exhausted during peak usage & a System.Net.Sockets.SocketExcetpion can be thrown. Also, re-using
    it avoids the cost of establishing new TCP connections.

    To use HttpClient effectively, the ConnectionClose property is set to false. Since this can
    prevent load balancing, a connection lease timeout is set on the base URL via ServicePointManager,
    which ensures that the connections timeout.
</p>


<h3>Attributes</h3>
<p>
    The Authorize Attribute class is used to provide security to the client at the action method level.
    Authorization of the action methods are determined by the user roles. Thus, the RoleProvider class
    is implemented by the CustomRoleProvider class. To configure the application to use
    CustomRoleProvider, the RoleManager element is added to the system.web element of Web.config.

    In the service, the Authorize Attribute is applied at the action method level to grant access to
    users based on their roles.

    Validation logic is added to the models via data annotatations. These specifications are enforced
    throughout the application. To avoid losing the validation attributes when the database changes, a
    metadata class that contains them is implemented & applied to partial classes of the models. This
    ensures that the model classes will not lose their attributes.


</p>


<h3>Forms Authentication</h3>
<p>
    Forms authentication is used to provide security to the client application. To implement Forms
    Authentication, the authentication mode is set to Forms & the loginurl is set to Accounts/Login
    in Web.config. After the username & hash are validated, the SetAuthCookie method of the
    FormsAuthentication class is invoked. It generates an authenticaton ticket for the user & adds
    it to the cookie collection of the response. FormAuthentication.SignOut is used to logout.
</p>


<h3>Role-based Menus</h3>
<p>
    Since only the Admin role can access the UsersController & only the Admin & User roles can access
    the MessagesController, menus to access these resources needs to be restricted based on roles.
    This is achieved by using User.IsInRole() (System.Security.Principal.IPrincipal namespace) in
    _Layout.cshtml.
</p>


<h3>Other Security Features</h3>
<p>
    AntiForgeryToken & ValidateAntiForgeryToken are used in the views & controllers of the client to
    protect against cross-site request forgery (i.e XSRF or CSRF). To protect against over-posting
    data, the bind attribute is used to include only the properties that are to be updated.
</p>


<h3>Technologies</h3>
<p>
    The Messenger Service uses ASP.NET web api 2.2, sql server 2017, & Entity Framework 6
    (database first approach)

    The Messenger Client uses ASP.NET MVC 5, sql server 2017, & Entity Framework 6 (database first
    approach).
</p>