@{
    ViewBag.Title = "About";
}
<h2>@ViewBag.Title.</h2>
<h3>@ViewBag.Message</h3>

<p>The Messenger Client uses ASP.NET MVC 5, sql server 2017, & Entity Framework 6 (database first approach).</p>
<p>
    Forms authentication is implemented. It uses the PBKDF2 hashing process via the Rfc2898DeriveBytes class.
    It uses a 32 byte salt & 5000 iterations to hash the provided password, which returns a 32 byte hash. Each user has a unique salt that is
    that is generated by the RNGCryptoServiceProvider class. The hashed password, salt, & the iteration count are stored in the client
    database & in the service database. To validate the password, the salt, iteration count, & provided password are used to generate a
    hash. Then it is compared to the original hash. The full length of the hashed password is checked everytime to protect against timing attacks. 

</p>

<p>It enhances data validation by adding a metadata class that contains the attributes, which ensures the model 
    classes can be regenerated without losing all of their attributes.</p>

<p>The Messenger Service uses ASP.NET web api 2.2, sql server 2017, & Entity Framework 6 (database first approach)</p>

<p>
    Token-based authentication is implemented to secure this resource. When a user registers/logins, the client calls
    the service & passes the username & hashed password to it.

    HttpClient is instantiated is instantiated & congigured in Global.Application_Start - to have one client to handle
    all requests to prevent against socket...
</p>

<p>
    Both projects have two roles/user groups & apply the authorize attribute with the Roles parameter at the action level.

    AntiForgeryToken & ValidateAntiForgeryToken are used in the views & controllers of the client to protect against

    put below in own words:
    The Bind attribute is another important security mechanism that keeps hackers from over-posting data to your model. You
    should only include properties in the bind attribute that you want to change. You can read about overposting and the bind
    attribute in my overposting security note. In the simple model used in this tutorial, we will be binding all the data in
    the model. The ValidateAntiForgeryToken attribute is used to prevent forgery of a request and is paired up with
    @Html.AntiForgeryToken() in the edit view file (Views\Movies\Edit.cshtml), a portion is shown below:

    @Html.AntiForgeryToken() generates a hidden form anti-forgery token that must match in the Edit method of the Movies controller.
    You can read more about Cross-site request forgery (also known as XSRF or CSRF) in my tutorial XSRF/CSRF Prevention in MVC.


    HttpClient is designed for re-use. You should use a single instance of it throughout the lifetime of your application, or at least as
    few as possible when request signatures will vary (explained later). The main reason for this is that each instance of HttpClient will
    open a new socket connection and on  high traffic sites you can exhaust the available pool and receive a System.Net.Sockets.SocketException.

    Additionally, by re-using instances you can avoid the not-insignificant overhead of establishing new TCP connections because HttpClient
    can re-use its existing connections, and do so in a thread safe manner.

    Here we have set up the client one time. All uses of it will :

    Use the same base address. You can tack on varying routes (e.g. /api/somecontroller, /api/someothercontroller ) without issue.
    Set the request content-type to application/json
    Will attempt to keep the connection open (.ConnectionClose = false) which makes more efficient use of the client.
    Since keeping connections open can prevent load balancing, we compensate by setting a connection lease timeout on the
    base URL through the ServicePointManager. This ensures connections are used efficiently but not indefinitely.

    While this clearly does not demonstrate all of the options on HttpRequestMessage, the point is that all of the
    configuration can be done on the message without affecting the efficiency of using a single instance of the client.
    So you can feel free to create as many varying request messages as you need.

    https://visualstudiomagazine.com/articles/2019/07/25/service-layer.aspx
    As an example of dead terminology (use this and be branded as "out of touch"), we don't have "data access layers" anymore -- instead, we implement the repository pattern.

    There are significant differences in concept, technology, and implementation between the repository pattern and the various ideas grouped under the "data access layer" rubric.

    But here's my point: A repository class isn't a "layer" -- it's just a class that I call.

    More dead terminology: We don't have "middle tier business objects" anymore. Instead, we have "the service layer."
    An Action method in an ASP.NET MVC Controller might call a service class that handles changing the ship date on a salesorder. But calling them a layer -- as if they existed in one place within your application -- is just dumb.

    The Importance of Service Classes: A Case Study

    https://medium.com/aeturnuminc/repository-pattern-with-dependency-injection-mvc-ef-code-first-91344413ba1c
    Dependency Injection
    Dependency Injection (DI) is a software design pattern, a particular case of Inversion of Control (IoC) pattern. IoC says high-level module should not depend on a low-level module, and both should depend on the abstraction. Basically, DI is a mechanism of injecting low-level instance to a high-level module. For an example.
    There are many IoC containers which provide the facility to Inject a dependency upon request. Following are few of the popular IoC containers.

    We are going to discuss the one of the most widely used a pattern called Repository Pattern. By using the repository pattern an application can have a clear separation between Business Layer and the Data Layer.

    As per the above diagram, Repository layer decouples the Domain logic from Data access logic hence Business Layer has no knowledge of Data Layer and vice versa. The operations/ communications between Business Layer, Data Layer with Repository Layer are implemented using Interface classes. (You will see later in this tutorial). Each layer has its own responsibilities and this is a clean example of Separation of Concerns(SoC).
    Benefits
    Centralized the data access logic therefore easy to maintain.
    Redundant Code.
    Provide great facility to write unit tests for Data Layer.
    Improves the readability.
    Disadvantages
    Though this reduces the number of lines of code you need to write, it increases the number of classes needs to maintain and this may increase the complexity of the project.
    The code still can be duplicated unless using Generic Repository classes.
    It is difficult to unit test the repositories still need to have an Integration test.
    Using this pattern with ORMs such as Entity Framework, NHibernate will distance from its features. Such an obvious example is Include method which one can retrieve the data with Eager Loading.

    You have just created an MVC application using Dependency Injection and Repository pattern with EF code first.

    https://visualstudiomagazine.com/blogs/tool-tracker/2019/02/designing-with-the-dependency.aspx?m=1

    You know this, already: the Dependency Inversion Principle is what drives the essential difference between ADO.NET and Entity Framework. With ADO.NET, it was your responsibility to create a connection (because you need a connection to the database), create a correctly configured command object (because you have to issue commands), call the appropriate execute method (because different SQL commands work differently) and then manage fetching rows and turning them into objects (because ... well, you get the picture). In other words, ADO.NET's API was driven by how the ADO.NET objects worked -- the reverse of the Dependency Inversion Principle.

    On the other hand, essentially what Entity Framework says is, "Tell me what objects you want and I'll get them for you." Entity Framework provides the API that the application wants: An object-oriented way of retrieving, adding, updating and deleting data.

    There are real cost-savings associated with the Dependency Inversion Principle. Because the principle requires that objects deliver the functionality that the client wants, interfaces tend to be more stable. Following the principle, APIs only change because the client program wants to do something differently (which, when you think about it, is the only reason we should be changing our code). You're welcome to upgrade how your objects work, of course ... but you're not allowed to change the API.
</p>